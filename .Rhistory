<<<<<<< Updated upstream
print(glue("Calibration holding {opt_a[1]} and {opt_a[2]}"))
iter_df <- data.frame(
rep(df[[opt_a[1]]], 2),
rep(df[[opt_a[2]]], 2),
c(df[[opt_b[1]]], df[[opt_c[1]]]),
c(df[[opt_b[2]]], df[[opt_c[2]]]),
c(rep(0, nrow(df)), rep(1, nrow(df)))
)
names(iter_df) = c(opt_a, "xn", "wn", "dummy")
mod = lm(log(eval(parse(text = opt_a[1]))/xn) ~ log(eval(parse(text = opt_a[2]))/wn) + dummy, data = iter_df)
sigma = round(-mod$coefficients[2], 3)
print(glue("sigma_{i} = {sigma}"))
print(glue("standard error = {summary(mod)$coefficients[2, 2]}"))
}
opts = list(
c("x1", "w1"),
c("x2", "w2"),
c("x3", "w3")
)
for (i in 1:3) {
opt_a = opts[[i]]
opts_iter = opts[-i]
opt_b = opts_iter[[1]]
opt_c = opts_iter[[2]]
print(glue("Calibration holding {opt_a[1]} and {opt_a[2]}"))
iter_df <- data.frame(
rep(df[[opt_a[1]]], 2),
rep(df[[opt_a[2]]], 2),
c(df[[opt_b[1]]], df[[opt_c[1]]]),
c(df[[opt_b[2]]], df[[opt_c[2]]]),
c(rep(0, nrow(df)), rep(1, nrow(df)))
)
names(iter_df) = c(opt_a, "xn", "wn", "dummy")
mod = lm(log(eval(parse(text = opt_a[1]))/xn) ~ log(eval(parse(text = opt_a[2]))/wn) + dummy, data = iter_df)
sigma = round(-mod$coefficients[2], 3)
print(glue("sigma_{i} = {sigma}"))
print(glue("standard error = {summary(mod)$coefficients[2, 2]}"))
}
x = c(8, 13, 17)
w = c(1, 1, 1)
x_sigma = x^(1/sigma)
a = x_sigma*w / sum(x_sigma*w)
a
scenarios = list(
c(0.92, 1, 0.9, 40.66),
c(1.04, 1.08, 1.09, 44.08),
c(0.86, 0.96, 1.04, 33.82),
c(1.05, 1.01, 0.94, 39.9)
)#w1, w2, w3, M
for (scenario in scenarios){
print("New Scenario")
print(ces_two_good_umax(
1,
sigma,
a[1],
a[2],
scenario[1],
scenario[2],
scenario[3]
))
}
scenarios = list(
c(0.92, 1, 0.9, 40.66),
c(1.04, 1.08, 1.09, 44.08),
c(0.86, 0.96, 1.04, 33.82),
c(1.05, 1.01, 0.94, 39.9)
)#w1, w2, w3, M
for (scenario in scenarios){
print("New Scenario")
print(ces_three_good_umax(
1,
sigma,
a[1],
a[2],
a[3],
scenario[1],
scenario[2],
scenario[3],
scenario[4]
))
}
sigma
sigma = 0.841
sigma = 0.841
```{r}
x = c(8, 13, 17)
w = c(1, 1, 1)
x_sigma = x^(1/sigma)
a = x_sigma*w / sum(x_sigma*w)
a
a = x_sigma*w / sum(x_sigma*w)
a
```{r}
scenarios = list(
c(0.92, 1, 0.9, 40.66),
c(1.04, 1.08, 1.09, 44.08),
c(0.86, 0.96, 1.04, 33.82),
c(1.05, 1.01, 0.94, 39.9)
)#w1, w2, w3, M
for (scenario in scenarios){
print("New Scenario")
print(ces_three_good_umax(
1,
sigma,
a[1],
a[2],
a[3],
scenario[1],
scenario[2],
scenario[3],
scenario[4]
))
}
source("Utility Maximization.R")
df <- read.csv("./Data Files/Quiz01_Q22_s.csv")
mod = lm(log(x1/x2) ~ log(w1/w2), data = df)
plot(log(df$w1/df$w2), log(df$x1/df$x2)) + abline(mod)
sigma = round(-mod$coefficients[2], 3)
sigma
x = c(19, 12)
w = c(1, 1)
x_sigma = x^(1/sigma)
a = x_sigma*w / sum(x_sigma*w)
a
scenarios = list(
c(1.11, 0.96, 33.79),
c(0.97, 1.06, 26.35),
c(0.93, 1.17, 35.03),
c(1.05, 1.15, 25.73)
)#w1, w2, w3, M
for (scenario in scenarios){
print("New Scenario")
print(ces_two_good_umax(
1,
sigma,
a[1],
a[2],
scenario[1],
scenario[2],
scenario[3]
))
}
library(glue)
df <- read.csv("./Data Files/Quiz01_Q23_s.csv") # Step 1 - Edit the file path
# Run this entire cell without editing
opts = list(
c("x1", "w1"),
c("x2", "w2"),
c("x3", "w3")
)
for (i in 1:3) {
opt_a = opts[[i]]
opts_iter = opts[-i]
opt_b = opts_iter[[1]]
opt_c = opts_iter[[2]]
print(glue("Calibration holding {opt_a[1]} and {opt_a[2]}"))
iter_df <- data.frame(
rep(df[[opt_a[1]]], 2),
rep(df[[opt_a[2]]], 2),
c(df[[opt_b[1]]], df[[opt_c[1]]]),
c(df[[opt_b[2]]], df[[opt_c[2]]]),
c(rep(0, nrow(df)), rep(1, nrow(df)))
)
names(iter_df) = c(opt_a, "xn", "wn", "dummy")
mod = lm(log(eval(parse(text = opt_a[1]))/xn) ~ log(eval(parse(text = opt_a[2]))/wn) + dummy, data = iter_df)
sigma = round(-mod$coefficients[2], 3)
print(glue("sigma_{i} = {sigma}"))
print(glue("standard error = {summary(mod)$coefficients[2, 2]}"))
}
sigma = 0.841 # Pick the sigma with the smallest standard error
x = c(8, 13, 17) # Step 3 - Edit these two things as usual
w = c(1, 1, 1)
x_sigma = x^(1/sigma)
a = x_sigma*w / sum(x_sigma*w)
a
# Step 4 - Edit the scenarios
scenarios = list(
c(0.92, 1, 0.9, 40.66),
c(1.04, 1.08, 1.09, 44.08),
c(0.86, 0.96, 1.04, 33.82),
c(1.05, 1.01, 0.94, 39.9)
)#w1, w2, w3, M
for (scenario in scenarios){
print("New Scenario")
print(ces_three_good_umax(
1,
sigma,
a[1],
a[2],
a[3],
scenario[1],
scenario[2],
scenario[3],
scenario[4]
))
}
df = read.csv("./Data Files/Quiz01_Q24_s.csv")
df$chosen = ifelse(df$ChosenAlternative == df$Alternative, 1, 0)
df = read.csv("./Data Files/Quiz01_Q25_s.csv")
df$chosen = ifelse(df$ChosenAlternative == df$Alternative, 1, 0)
library(mlogit)
library(mlogit)
?mlogit
?mlogit.data
df = read.csv("./Data Files/Quiz01_Q25_s.csv")
df$chosen = (df$ChosenAlternative == df$Alternative)
df
view(df)
View(df)
names(df)
library(uuid)
library(mlogit)
install.packages("uuid")
library(uuid)
df$choiceID = uuid(df$ChoiceSet)
df$choiceID = uuid::UUIDgenerate(use.time = TRUE)
df$choiceID = uuid::UUIDgenerate(n = len(df), use.time = TRUE)
df$choiceID = uuid::UUIDgenerate(n = length(df), use.time = TRUE)
df$choiceID = c(uuid::UUIDgenerate(n = length(df), use.time = TRUE))
c(uuid::UUIDgenerate(n = length(df), use.time = TRUE))
df
len(df)
length(df)
df$choiceID = uuid::UUIDgenerate(n = nrow(df), use.time = TRUE)
log_data = mlogit.data(df, choice = "chosen", shape = "long", chid.var = "choiceID", alt.var = "Alternative")
View(log_data)
?mlogit
names(df)
mlogit(chosen~Weed + Crawl + Fly + Cost|0, data = log_data)
mlogit(chosen~Weed + Crawl + Fly + Cost|+0, data = log_data)
mlogit(chosen~Weed + Crawl + Fly + Cost| F |+0, data = log_data)
mlogit(chosen~Weed + Crawl + Fly + Cost, data = log_data)
```{r}
df = read.csv("./Data Files/Quiz01_Q25_s.csv")
df$chosen = (df$ChosenAlternative == df$Alternative)
df$choiceID = (df$ID - 1)*6 + df$ChoiceSet
log_data = mlogit.data(df, choice = "chosen", shape = "long", chid.var = "choiceID", alt.var = "Alternative")
mlogit(chosen~Weed + Crawl + Fly + Cost, data = log_data)
mlogit(chosen~Weed + Crawl + Fly + Cost |  -1, data = log_data)
mlogit(chosen~Weed + Crawl + Fly + Cost | F |-1, data = log_data)
mlogit(chosen~Weed + Crawl + Fly + Cost |-1, data = log_data)
mlogit(chosen~Weed + Crawl + Fly + Cost| -1, data = log_data)
mlogit(chosen~Weed + Crawl + Fly + Cost| -1, data = log_data)
mod1 = mlogit(chosen~Weed + Crawl + Fly + Cost| -1, data = log_data)
summary(mod1)
coefs = coef(mod1)
coefs
print(exp(coefs[i,]))
}
print(exp(coefs[i]))
print(coefs[i])
for (i in 1:3) {
print(coefs[i])
}
library(glue)
print(glue("WTP = {coefs[i]/coefs[4}"))
print(glue("WTP = {coefs[i]/coefs[4]}"))
for (i in 1:3) {
print(coefs[i])
print(glue("WTP = {coefs[i]/coefs[4]}"))
}
v_cv = vcov(mod1)
coefs
coefs[4]
coefs[[4]]
# Close all graphics, clear memory and screen
graphics.off(); remove(list=ls());cat("\14");
# Load mlogit package
library("mlogit")
# Load data from CSV and store in CM object
Ex0103<-read.csv("Example_0103_data.csv")
# Load data from CSV and store in CM object
Ex0103<-read.csv("./Example_0103_data.csv")
# Load data from CSV and store in CM object
Ex0103<-read.csv("./Topic 1/Example_0103_data.csv")
# Extract (and display) the choice 5 of the 200th respondent
Res200Choice5=Ex0103[(Ex0103$id==200)&(Ex0103$ChoiceSet==5),]
# Calculate the expected utility generated by the three attributes
R200C5U1=0.059*Res200Choice5[1,"Wetland"]+ 0.512*Res200Choice5[1,"Bird"]+ 0.519*Res200Choice5[1,"Fish"]+(-0.621)*Res200Choice5[1,"Cost"]
R200C5U2=0.059*Res200Choice5[2,"Wetland"]+ 0.512*Res200Choice5[2,"Bird"]+ 0.519*Res200Choice5[2,"Fish"]+(-0.621)*Res200Choice5[2,"Cost"]
R200C5U3=0.059*Res200Choice5[3,"Wetland"]+ 0.512*Res200Choice5[3,"Bird"]+ 0.519*Res200Choice5[3,"Fish"]+(-0.621)*Res200Choice5[3,"Cost"]
# Extract (and display) the choice 1 of the 2nd respondent
Res2Choice1=Ex0103[(Ex0103$id==2)&(Ex0103$ChoiceSet==1),]
# Calculate the expected utility generated by the three attributes
R2C1U1=0.059*Res2Choice1[1,"Wetland"]+ 0.512*Res2Choice1[1,"Bird"]+ 0.519*Res2Choice1[1,"Fish"]+(-0.621)*Res2Choice1[1,"Cost"]
R2C1U2=0.059*Res2Choice1[2,"Wetland"]+ 0.512*Res2Choice1[2,"Bird"]+ 0.519*Res2Choice1[2,"Fish"]+(-0.621)*Res2Choice1[2,"Cost"]
R2C1U3=0.059*Res2Choice1[3,"Wetland"]+ 0.512*Res2Choice1[3,"Bird"]+ 0.519*Res2Choice1[3,"Fish"]+(-0.621)*Res2Choice1[3,"Cost"]
# Generate unique ID for each situation where a choice is made.
Ex0103$ChoiceID<-(Ex0103$id-1)*6+Ex0103$ChoiceSet
# Generate a dummy variable for each alternative (1=selected, 0=non-selected)
Ex0103$ChoiceYesNo<-(Ex0103$Alt==Ex0103$Choice)
# Generate a new dataset in which R knows what is what
mlogitdata<-mlogit.data(Ex0103,choice="ChoiceYesNo",shape="long",chid.var="ChoiceID",alt.var="Alt")
# Eetimate the baseline specification, store the result in object 'baseline' and display it
baseline<-mlogit(ChoiceYesNo~Wetland+Bird+Fish+Cost|+0,data=mlogitdata); summary(baseline)
# Store the variance-covariance matrix in object V and display it
V<-vcov(baseline); V
# Store the coefficient vector in object betahat and display it
betahat<-coef(baseline); betahat;
# Calculate the WTP for Wetland and its standard error (using Delta method) manually
WTP_Wetland_Manual=-0.059295/(-0.6208694); WTP_Wetland_Manual;
se_WTP_Wetland_Mannual=sqrt(1/(-0.62084694)^2*(0.0001934934-2*0.059295/(-0.6208694)*(-0.0007018273)+(0.059295/(-0.6208694))^2*0.0043723126)); se_WTP_Wetland_Mannual
# Calculate the standard error of the WTP using the estimate notations
se_WTP_Wetland<- sqrt(1/betahat[[4]]^2*(V[1,1]-2*betahat[[1]]/betahat[[4]]*V[1,4]+(betahat[[1]]/betahat[[4]])^2*V[4,4]));se_WTP_Wetland
# Calculate the standard error of the WTP using the estimate notations
se_WTP_Wetland<- sqrt(1/betahat[[4]]^2*(V[1,1]+2*betahat[[1]]/betahat[[4]]*V[1,4]+(betahat[[1]]/betahat[[4]])^2*V[4,4]));se_WTP_Wetland
# Calculate the standard error of the WTP using the estimate notations
se_WTP_Wetland<- sqrt(1/betahat[[4]]^2*(V[1,1]-2*betahat[[1]]/betahat[[4]]*V[1,4]+(betahat[[1]]/betahat[[4]])^2*V[4,4]));se_WTP_Wetland
??rpar
?mlogit
temp <- mlogit(ChoiceYesNo~Wetland+Bird+Fish+Cost|-1,
data=mlogitdata,
rpar = c(Wetland='n', Bird='n', Fish='n'),
correlation = FALSE
)
coef(temp)
temp <- mlogit(ChoiceYesNo~Wetland+Bird+Fish+Cost|-1,
data=mlogitdata,
rpar = c(Wetland='n', Bird='n', Fish='n'),
correlation = TRUE
)
coef(temp)
temp <- mlogit(ChoiceYesNo~Wetland+Bird+Fish+Cost|-1,
data=mlogitdata,
rpar = c(Wetland='n', Bird='n', Fish='n'),
correlation = FALSE
)
coef(temp)
temp <- mlogit(ChoiceYesNo~Wetland+Bird+Fish+Cost|-1,
data=mlogitdata,
rpar = c(Wetland='n', Bird='n', Fish='n'),
correlation = FALSE
)
temp <- mlogit(ChoiceYesNo~Wetland+Bird+Fish+Cost|-1,
data=mlogitdata,
rpar = c(Wetland='n', Bird='n', Fish='n'),
R = 100,
correlation = FALSE
)
coef(temp)
se_wtp <- function(i, wtp) {
return 1/coefs[4] * sqrt(v_cv[i, i] - 2 * wtp * v_cv[i, 4] + wtp^2 * v_cv[4, 4])
return (1/coefs[4] * sqrt(v_cv[i, i] - 2 * wtp * v_cv[i, 4] + wtp^2 * v_cv[4, 4]))
coefs
df = read.csv("./Data Files/Quiz01_Q24_s.csv")
df$chosen = (df$ChosenAlternative == df$Alternative)
library(mlogit)
library(glue)
library(mlogit)
library(glue)
```{r}
df = read.csv("./Data Files/Quiz01_Q25_s.csv")
df$chosen = (df$ChosenAlternative == df$Alternative)
df$choiceID = (df$ID - 1)*6 + df$ChoiceSet
df$choiceID = (df$ID - 1)*6 + df$ChoiceSet
```{r}
log_data = mlogit.data(df, choice = "chosen", shape = "long", chid.var = "choiceID", alt.var = "Alternative")
mod1 = mlogit(chosen~Weed + Crawl + Fly + Cost| -1, data = log_data)
mod1 = mlogit(chosen~Weed + Crawl + Fly + Cost| -1, data = log_data)
```{r}
summary(mod1)
df$choiceID = (df$ID - 1)*5 + df$ChoiceSet
df = read.csv("./Data Files/Quiz01_Q25_s.csv")
df$chosen = (df$ChosenAlternative == df$Alternative)
df$choiceID = (df$ID - 1)*5 + df$ChoiceSet
df$choiceID = (df$ID - 1)*5 + df$ChoiceSet
```{r}
log_data = mlogit.data(df, choice = "chosen", shape = "long", chid.var = "choiceID", alt.var = "Alternative")
mod1 = mlogit(chosen~Weed + Crawl + Fly + Cost| -1, data = log_data)
mod1 = mlogit(chosen~Weed + Crawl + Fly + Cost| -1, data = log_data)
```{r}
summary(mod1)
summary(mod1)
```{r}
coefs = coef(mod1)
v_cv = vcov(mod1)
coefs
se_wtp <- function(i, wtp) {
return (1/coefs[4] * sqrt(v_cv[i, i] - 2 * wtp * v_cv[i, 4] + wtp^2 * v_cv[4, 4]))
}
for (i in 1:3) {
print(coefs[i])
wtp = coefs[i]/coefs[4]
print(glue("WTP = {wtp}"))
se = se_wtp(i, wtp)
print(glue("SE = {se}"))
}
mod2 = mlogit(chosen~Weed + Crawl + Fly + Cost| F |-1, data = log_data)
summary(mod2)
mod2 = mlogit(chosen~Weed + Crawl + Fly + Cost| F -1|-1, data = log_data)
summary(mod2)
mod2 = mlogit(chosen~Weed + Crawl + Fly + Cost| F -1, data = log_data)
summary(mod2)
mod2 = mlogit(chosen~ Cost | Weed + Crawl + Fly | F -1, data = log_data)
mod2 = mlogit(chosen~ Cost | Weed + Crawl + Fly | F , data = log_data)
summary(mod2)
mod2 = mlogit(chosen~ Weed + Crawl + Fly + Cost | F , data = log_data)
summary(mod2)
mod2 = mlogit(chosen~ Weed + Crawl + Fly + Cost | | F , data = log_data)
summary(mod2)
mod2 = mlogit(chosen~ Weed + Crawl + Fly + Cost | -1 | F , data = log_data)
summary(mod2)
mod2 = mlogit(chosen~ Weed + Crawl + Fly + Cost | -1 | F , data = log_data)
mod2 = mlogit(chosen~ Weed + Crawl + Fly + Cost | + | F , data = log_data)
mod2 = mlogit(chosen~ Weed + Crawl + Fly + Cost | +0| F , data = log_data)
mod2 = mlogit(chosen~ Weed + Crawl + Fly + Cost | +0| F +0,data = log_data)
mod2 = mlogit(chosen~ Weed + Crawl + Fly + Cost | F +0,data = log_data)
summary(mod2)
mod2 = mlogit(chosen ~ Weed + Crawl + Fly  | Cost | F +0,data = log_data)
mod2 = mlogit(chosen ~ Weed + Crawl + Fly  | Cost + 0| F +0,data = log_data)
mod2 = mlogit(chosen ~ Weed*F + Crawl*F + Fly*F + Cost,data = log_data)
mod2 = mlogit(chosen ~ Weed*F + Crawl*F + Fly*F + Cost|-1,data = log_data)
mod2 = mlogit(chosen ~ I(Weed*F) + I(Crawl*F) + I(Fly*F) + Cost|-1,data = log_data)
summary(mod2)
mod2 = mlogit(chosen ~ Weed + Crawl + Fly + Cost + I(Weed*F) + I(Crawl*F) + I(Fly*F)|-1,data = log_data)
summary(mod2)
wtp = -coefs[i]/coefs[4]
print(glue("WTP = {wtp}"))
se = se_wtp(i, wtp)
print(glue("SE = {se}"))
for (i in 1:3) {
print(coefs[i])
wtp = -coefs[i]/coefs[4]
print(glue("WTP = {wtp}"))
se = se_wtp(i, wtp)
print(glue("SE = {se}"))
}
log_data = mlogit.data(df, choice = "chosen", shape = "long", chid.var = "choiceID", alt.var = "Alternative")
mod1 = mlogit(chosen~Weed + Crawl + Fly + Cost| -1, data = log_data)
mod1 = mlogit(chosen~Weed + Crawl + Fly + Cost| -1, data = log_data)
```{r}
summary(mod1)
summary(mod1)
```{r}
coefs = coef(mod1)
v_cv = vcov(mod1)
coefs
coefs
```{r}
se_wtp <- function(i, wtp) {
return (1/coefs[4] * sqrt(v_cv[i, i] - 2 * wtp * v_cv[i, 4] + wtp^2 * v_cv[4, 4]))
}
se_wtp <- function(i, wtp) {
return (1/coefs[4] * sqrt(v_cv[i, i] - 2 * wtp * v_cv[i, 4] + wtp^2 * v_cv[4, 4]))
}
```{r}
for (i in 1:3) {
print(coefs[i])
wtp = -coefs[i]/coefs[4]
print(glue("WTP = {wtp}"))
se = se_wtp(i, wtp)
print(glue("SE = {se}"))
}
for (i in 1:3) {
print(coefs[i])
wtp = coefs[i]/coefs[4]
print(glue("WTP = {wtp}"))
se = se_wtp(i, wtp)
print(glue("SE = {se}"))
}
wtp = -coefs[i]/coefs[4]
print(glue("WTP = {wtp}"))
se = se_wtp(i, wtp)
print(glue("SE = {se}"))
for (i in 1:3) {
print(coefs[i])
wtp = -coefs[i]/coefs[4]
print(glue("WTP = {wtp}"))
se = se_wtp(i, wtp)
print(glue("SE = {se}"))
}
for (i in 1:3) {
print(coefs[i])
wtp = coefs[i]/coefs[4]
print(glue("WTP = {wtp}"))
se = se_wtp(i, wtp)
print(glue("SE = {se}"))
}
?anova
?lrtest
setwd("D:/GitHub/MIDECSem3")
df = read.csv("./Data Files/Quiz01_Q24_s.csv")
df$chosen = (df$ChosenAlternative == df$Alternative)
library(mlogit)
library(glue)
df = read.csv("./Data Files/Quiz01_Q25_s.csv")
df$chosen = (df$ChosenAlternative == df$Alternative)
df$choiceID = (df$ID - 1)*5 + df$ChoiceSet
log_data = mlogit.data(df, choice = "chosen", shape = "long", chid.var = "choiceID", alt.var = "Alternative")
mod1 = mlogit(chosen~Weed + Crawl + Fly + Cost| -1, data = log_data)
summary(mod1)
coefs = coef(mod1)
v_cv = vcov(mod1)
coefs
se_wtp <- function(i, wtp) {
return (1/coefs[4] * sqrt(v_cv[i, i] - 2 * wtp * v_cv[i, 4] + wtp^2 * v_cv[4, 4]))
}
for (i in 1:3) {
print(coefs[i])
wtp = coefs[i]/coefs[4]
print(glue("WTP = {wtp}"))
se = se_wtp(i, wtp)
print(glue("SE = {se}"))
}
mod2 = mlogit(chosen ~ Weed + Crawl + Fly + Cost + I(Weed*F) + I(Crawl*F) + I(Fly*F)|-1,data = log_data)
summary(mod2)
library(lmtest)
?lrtest
?lrtest
lrtest(mod2, mod1)
lrtest(mod1, mod2)
lrtest(mod2, mod1)
=======
##Equations
x_1=M*(a1/w1)^(s)*1/(w1*(a1/w1)^(s)+w2*(a2/w2)^(s)+w3*(a3/w3)^(s))
x_2=M*(a2/w2)^(s)*1/(w1*(a1/w1)^(s)+w2*(a2/w2)^(s)+w3(a3/w3)^(s))
x_3=M*(a3/w3)^(s)*1/(w1*(a1/w1)^(s)+w2*(a2/w2)^(s)+w3(a3/w3)^(s))
##Q12
##Variables
a1=0.33
a2=0.4
a3=0.27
s=0.74
w1=5
w2=5
w3=5
M=74
##Equations
x_1=M*(a1/w1)^(s)*1/(w1*(a1/w1)^(s)+w2*(a2/w2)^(s)+w3*(a3/w3)^(s))
x_2=M*(a2/w2)^(s)*1/(w1*(a1/w1)^(s)+w2*(a2/w2)^(s)+w3*(a3/w3)^(s))
x_3=M*(a3/w3)^(s)*1/(w1*(a1/w1)^(s)+w2*(a2/w2)^(s)+w3*(a3/w3)^(s))
v=M*(w1*(a1/w1)^(s)+w2*(a2/w2)^(s)+w3*(a3/w3)^(s))^(1/s-1)
A = 1
sigma = 0.63
r = 1 - 1/sigma
a1 = 0.75
a2 = 0.25
w1 = 6
w2 = 6
M = 53
x_1 = ( M * (a1/w1)^sigma ) / (w1 * (a1/w1)^sigma + w2 * (a2/w2)^sigma)
x_2 = ( M * (a2/w2)^sigma ) / (w1 * (a1/w1)^sigma + w2 * (a2/w2)^sigma)
v = A * M * (w1 * (a1/w1)^sigma + w2 * (a2/w2)^sigma) ^ (1/(sigma - 1))
x_1
x_2
v
A = 1
sigma = 0.63
r = 1 - 1/sigma
a1 = 0.75
a2 = 0.25
w1 = 6
w2 = 7
M = 56
x_1 = ( M * (a1/w1)^sigma ) / (w1 * (a1/w1)^sigma + w2 * (a2/w2)^sigma)
x_2 = ( M * (a2/w2)^sigma ) / (w1 * (a1/w1)^sigma + w2 * (a2/w2)^sigma)
v = A * M * (w1 * (a1/w1)^sigma + w2 * (a2/w2)^sigma) ^ (1/(sigma - 1))
x_1
x_2
v
A = 1
sigma = 0.63
r = 1 - 1/sigma
a1 = 0.75
a2 = 0.25
w1 = 7
w2 = 5
M = 72
x_1 = ( M * (a1/w1)^sigma ) / (w1 * (a1/w1)^sigma + w2 * (a2/w2)^sigma)
x_2 = ( M * (a2/w2)^sigma ) / (w1 * (a1/w1)^sigma + w2 * (a2/w2)^sigma)
v = A * M * (w1 * (a1/w1)^sigma + w2 * (a2/w2)^sigma) ^ (1/(sigma - 1))
x_1
x_2
v
A = 1
sigma = 0.63
r = 1 - 1/sigma
a1 = 0.75
a2 = 0.25
w1 = 7
w2 = 7
M = 60
x_1 = ( M * (a1/w1)^sigma ) / (w1 * (a1/w1)^sigma + w2 * (a2/w2)^sigma)
x_2 = ( M * (a2/w2)^sigma ) / (w1 * (a1/w1)^sigma + w2 * (a2/w2)^sigma)
v = A * M * (w1 * (a1/w1)^sigma + w2 * (a2/w2)^sigma) ^ (1/(sigma - 1))
x_1
x_2
v
A = 1
r = 1 - 1/sigma
sigma = 0.74
a1 = 0.33
a2 = 0.4
a3 = 0.27
w1 = 5
w2 = 5
w3 = 5
M = 74
x_1 = ( M * (a1/w1)^sigma ) / (w1 * (a1/w1)^sigma + w2 * (a2/w2)^sigma + w3 * (a3/w3)^sigma)
x_2 = ( M * (a2/w2)^sigma ) / (w1 * (a1/w1)^sigma + w2 * (a2/w2)^sigma + w3 * (a3/w3)^sigma)
x_2 = ( M * (a3/w3)^sigma ) / (w1 * (a1/w1)^sigma + w2 * (a2/w2)^sigma + w3 * (a3/w3)^sigma)
v = A * M * (w1 * (a1/w1)^sigma + w2 * (a2/w2)^sigma + w3 * (a3/w3)^sigma) ^ (1/(sigma - 1))
x_1
x_2
X_3
v
A = 1
r = 1 - 1/sigma
sigma = 0.74
a1 = 0.33
a2 = 0.4
a3 = 0.27
w1 = 5
w2 = 5
w3 = 5
M = 74
x_1 = ( M * (a1/w1)^sigma ) / (w1 * (a1/w1)^sigma + w2 * (a2/w2)^sigma + w3 * (a3/w3)^sigma)
x_2 = ( M * (a2/w2)^sigma ) / (w1 * (a1/w1)^sigma + w2 * (a2/w2)^sigma + w3 * (a3/w3)^sigma)
x_3 = ( M * (a3/w3)^sigma ) / (w1 * (a1/w1)^sigma + w2 * (a2/w2)^sigma + w3 * (a3/w3)^sigma)
v = A * M * (w1 * (a1/w1)^sigma + w2 * (a2/w2)^sigma + w3 * (a3/w3)^sigma) ^ (1/(sigma - 1))
x_1
x_2
X_3
A = 1
r = 1 - 1/sigma
sigma = 0.74
a1 = 0.33
a2 = 0.4
a3 = 0.27
w1 = 5
w2 = 5
w3 = 5
M = 74
x_1 = ( M * (a1/w1)^sigma ) / (w1 * (a1/w1)^sigma + w2 * (a2/w2)^sigma + w3 * (a3/w3)^sigma)
x_2 = ( M * (a2/w2)^sigma ) / (w1 * (a1/w1)^sigma + w2 * (a2/w2)^sigma + w3 * (a3/w3)^sigma)
x_3 = ( M * (a3/w3)^sigma ) / (w1 * (a1/w1)^sigma + w2 * (a2/w2)^sigma + w3 * (a3/w3)^sigma)
v = A * M * (w1 * (a1/w1)^sigma + w2 * (a2/w2)^sigma + w3 * (a3/w3)^sigma) ^ (1/(sigma - 1))
x_1
x_2
x_3
v
A = 1
r = 1 - 1/sigma
sigma = 0.74
a1 = 0.33
a2 = 0.4
a3 = 0.27
w1 = 5
w2 = 7
w3 = 5
M = 72
x_1 = ( M * (a1/w1)^sigma ) / (w1 * (a1/w1)^sigma + w2 * (a2/w2)^sigma + w3 * (a3/w3)^sigma)
x_2 = ( M * (a2/w2)^sigma ) / (w1 * (a1/w1)^sigma + w2 * (a2/w2)^sigma + w3 * (a3/w3)^sigma)
x_3 = ( M * (a3/w3)^sigma ) / (w1 * (a1/w1)^sigma + w2 * (a2/w2)^sigma + w3 * (a3/w3)^sigma)
v = A * M * (w1 * (a1/w1)^sigma + w2 * (a2/w2)^sigma + w3 * (a3/w3)^sigma) ^ (1/(sigma - 1))
x_1
x_2
x_3
v
A = 1
r = 1 - 1/sigma
sigma = 0.74
a1 = 0.33
a2 = 0.4
a3 = 0.27
w1 = 5
w2 = 4
w3 = 6
M = 59
x_1 = ( M * (a1/w1)^sigma ) / (w1 * (a1/w1)^sigma + w2 * (a2/w2)^sigma + w3 * (a3/w3)^sigma)
x_2 = ( M * (a2/w2)^sigma ) / (w1 * (a1/w1)^sigma + w2 * (a2/w2)^sigma + w3 * (a3/w3)^sigma)
x_3 = ( M * (a3/w3)^sigma ) / (w1 * (a1/w1)^sigma + w2 * (a2/w2)^sigma + w3 * (a3/w3)^sigma)
v = A * M * (w1 * (a1/w1)^sigma + w2 * (a2/w2)^sigma + w3 * (a3/w3)^sigma) ^ (1/(sigma - 1))
x_1
x_2
x_3
v
A = 1
r = 1 - 1/sigma
sigma = 0.74
a1 = 0.33
a2 = 0.4
a3 = 0.27
w1 = 5
w2 = 8
w3 = 6
M = 56
x_1 = ( M * (a1/w1)^sigma ) / (w1 * (a1/w1)^sigma + w2 * (a2/w2)^sigma + w3 * (a3/w3)^sigma)
x_2 = ( M * (a2/w2)^sigma ) / (w1 * (a1/w1)^sigma + w2 * (a2/w2)^sigma + w3 * (a3/w3)^sigma)
x_3 = ( M * (a3/w3)^sigma ) / (w1 * (a1/w1)^sigma + w2 * (a2/w2)^sigma + w3 * (a3/w3)^sigma)
v = A * M * (w1 * (a1/w1)^sigma + w2 * (a2/w2)^sigma + w3 * (a3/w3)^sigma) ^ (1/(sigma - 1))
x_1
x_2
x_3
v
A = 1
a1 = 0.2
a2 = 0.8
w1 = 5
w2 = 7
U = 72
xh_1 = (a1/w1) * (A^-1 * U * (a1/w1)^-a1 * (a2/w2)^-a2)^(1/(a1 + a2))
xh_2 = (a2/w2) * (A^-1 * U * (a1/w1)^-a1 * (a2/w2)^-a2)^(1/(a1 + a2))
e = (a1 + a2) * (A^-1 * U * (a1/w1)^-a1 * (a2/w2)^-a2)^(1/(a1 + a2))
xh_1
xh_2
e
A = 1
a1 = 0.2
a2 = 0.8
w1 = 5
w2 = 7
U = 72
xh_1 = (a1/w1) * (A^-1 * U * (a1/w1)^-a1 * (a2/w2)^-a2)^(1/(a1 + a2))
xh_2 = (a2/w2) * (A^-1 * U * (a1/w1)^-a1 * (a2/w2)^-a2)^(1/(a1 + a2))
e = (a1 + a2) * (A^-1 * U * (a1/w1)^-a1 * (a2/w2)^-a2)^(1/(a1 + a2))
xh_1
xh_2
e
A = 1
a1 = 0.2
a2 = 0.8
w1 = 5
w2 = 4
U = 52
xh_1 = (a1/w1) * (A^-1 * U * (a1/w1)^-a1 * (a2/w2)^-a2)^(1/(a1 + a2))
xh_2 = (a2/w2) * (A^-1 * U * (a1/w1)^-a1 * (a2/w2)^-a2)^(1/(a1 + a2))
e = (a1 + a2) * (A^-1 * U * (a1/w1)^-a1 * (a2/w2)^-a2)^(1/(a1 + a2))
xh_1
xh_2
e
A = 1
a1 = 0.2
a2 = 0.8
w1 = 6
w2 = 6
U = 66
xh_1 = (a1/w1) * (A^-1 * U * (a1/w1)^-a1 * (a2/w2)^-a2)^(1/(a1 + a2))
xh_2 = (a2/w2) * (A^-1 * U * (a1/w1)^-a1 * (a2/w2)^-a2)^(1/(a1 + a2))
e = (a1 + a2) * (A^-1 * U * (a1/w1)^-a1 * (a2/w2)^-a2)^(1/(a1 + a2))
xh_1
xh_2
e
A = 1
a1 = 0.2
a2 = 0.8
w1 = 6
w2 = 7
U = 77
xh_1 = (a1/w1) * (A^-1 * U * (a1/w1)^-a1 * (a2/w2)^-a2)^(1/(a1 + a2))
xh_2 = (a2/w2) * (A^-1 * U * (a1/w1)^-a1 * (a2/w2)^-a2)^(1/(a1 + a2))
e = (a1 + a2) * (A^-1 * U * (a1/w1)^-a1 * (a2/w2)^-a2)^(1/(a1 + a2))
xh_1
xh_2
e
A = 1
r = 1 - 1/sigma
sigma = 1.43
a1 = 0.7
a2 = 0.3
w1 = 5
w2 = 4
U = 72
xh_1 = U * (a1/w1)^sigma * (w1 * (a1/w1)^sigma + w2 * (a2/w2)^sigma)^(sigma/1-sigma)
xh_2 = U * (a2/w2)^sigma * (w1 * (a1/w1)^sigma + w2 * (a2/w2)^sigma)^(sigma/1-sigma)
e = U * (w1 * (a1/w1)^sigma + w2 * (a2/w2)^sigma)^(sigma/1-sigma)
xh_1
xh_2
e
A = 1
r = 1 - 1/sigma
sigma = 1.43
a1 = 0.7
A = 1
sigma = 1.43
r = 1 - 1/sigma
a1 = 0.7
a2 = 0.3
w1 = 5
w2 = 4
U = 72
xh_1 = U * (a1/w1)^sigma * (w1 * (a1/w1)^sigma + w2 * (a2/w2)^sigma)^(sigma/1-sigma)
xh_2 = U * (a2/w2)^sigma * (w1 * (a1/w1)^sigma + w2 * (a2/w2)^sigma)^(sigma/1-sigma)
e = U * (w1 * (a1/w1)^sigma + w2 * (a2/w2)^sigma)^(sigma/1-sigma)
A = 1
sigma = 1.43
r = 1 - 1/sigma
a1 = 0.7
a2 = 0.3
w1 = 5
w2 = 4
U = 72
xh_1 = U * (a1/w1)^sigma * (w1 * (a1/w1)^sigma + w2 * (a2/w2)^sigma)^(sigma/1-sigma)
xh_2 = U * (a2/w2)^sigma * (w1 * (a1/w1)^sigma + w2 * (a2/w2)^sigma)^(sigma/1-sigma)
e = U * (w1 * (a1/w1)^sigma + w2 * (a2/w2)^sigma)^(sigma/1-sigma)
xh_1
xh_2
e
A = 1
sigma = 0.43
r = 1 - 1/sigma
a1 = 0.7
a2 = 0.3
w1 = 5
w2 = 4
U = 72
xh_1 = U * (a1/w1)^sigma * (w1 * (a1/w1)^sigma + w2 * (a2/w2)^sigma)^(sigma/1-sigma)
xh_2 = U * (a2/w2)^sigma * (w1 * (a1/w1)^sigma + w2 * (a2/w2)^sigma)^(sigma/1-sigma)
e = U * (w1 * (a1/w1)^sigma + w2 * (a2/w2)^sigma)^(sigma/1-sigma)
xh_1
xh_2
e
A = 1
sigma = 0.43
r = 1 - 1/sigma
a1 = 0.7
a2 = 0.3
w1 = 7
w2 = 7
U = 73
xh_1 = U * (a1/w1)^sigma * (w1 * (a1/w1)^sigma + w2 * (a2/w2)^sigma)^(sigma/1-sigma)
xh_2 = U * (a2/w2)^sigma * (w1 * (a1/w1)^sigma + w2 * (a2/w2)^sigma)^(sigma/1-sigma)
e = U * (w1 * (a1/w1)^sigma + w2 * (a2/w2)^sigma)^(sigma/1-sigma)
xh_1
xh_2
e
A = 1
sigma = 0.99
r = 1 - 1/sigma
a1 = 0.4
a2 = 0.33
a3 = 0.27
w1 = 4
w2 = 5
w3 = 6
U = 71
xh_1 = U * (a1/w1)^sigma * (w1 * (a1/w1)^sigma + w2 * (a2/w2)^sigma + w3 * (a3/w3)^sigma)^(sigma/1-sigma)
xh_2 = U * (a2/w2)^sigma * (w1 * (a1/w1)^sigma + w2 * (a2/w2)^sigma + w3 * (a3/w3)^sigma)^(sigma/1-sigma)
xh_3 = U * (a3/w3)^sigma * (w1 * (a1/w1)^sigma + w2 * (a2/w2)^sigma + w3 * (a3/w3)^sigma)^(sigma/1-sigma)
e = U * (w1 * (a1/w1)^sigma + w2 * (a2/w2)^sigma + w3 * (a3/w3)^sigma)^(sigma/1-sigma)
xh_1
xh_2
xh_3
e
A = 1
sigma = 1.43
r = 1 - 1/sigma
a1 = 0.7
a2 = 0.3
w1 = 7
w2 = 7
U = 73
xh_1 = U * (a1/w1)^sigma * (w1 * (a1/w1)^sigma + w2 * (a2/w2)^sigma)^(sigma/1-sigma)
xh_2 = U * (a2/w2)^sigma * (w1 * (a1/w1)^sigma + w2 * (a2/w2)^sigma)^(sigma/1-sigma)
e = U * (w1 * (a1/w1)^sigma + w2 * (a2/w2)^sigma)^(sigma/1-sigma)
xh_1
xh_2
e
A = 1
sigma = 1.43
r = 1 - 1/sigma
a1 = 0.7
a2 = 0.3
w1 = 7
w2 = 7
U = 73
xh_1 = U * ( (a1 / w1)^sigma ) / ( a1 * (1/w1)^sigma + a2 * (1/w2)^sigma )
xh_2 = U * (a2/w2)^sigma * (w1 * (a1/w1)^sigma + w2 * (a2/w2)^sigma)^(sigma/1-sigma)
e = U * (w1 * (a1/w1)^sigma + w2 * (a2/w2)^sigma)^(sigma/1-sigma)
xh_1
xh_2
e
A = 1
sigma = 1.43
r = 1 - 1/sigma
a1 = 0.7
a2 = 0.3
w1 = 7
w2 = 7
U = 73
xh_1 = U * ( (a1 / w1)^sigma ) / ( a1 * (1/w1)^sigma + a2 * (1/w2)^sigma )
xh_2 = U * ( (a2 / w2)^sigma ) / ( a1 * (1/w1)^sigma + a2 * (1/w2)^sigma )
e = U * ( a1 * (1/w1)^sigma + a2 * (1/w2)^sigma )^(1/(1-sigma))
xh_1
xh_2
e
A = 1
sigma = 1.43
r = 1 - 1/sigma
a1 = 0.7
a2 = 0.3
w1 = 5
w2 = 4
U = 72
xh_1 = U * ( (a1 / w1)^sigma ) / ( a1 * (1/w1)^sigma + a2 * (1/w2)^sigma )
xh_2 = U * ( (a2 / w2)^sigma ) / ( a1 * (1/w1)^sigma + a2 * (1/w2)^sigma )
e = U * ( a1 * (1/w1)^sigma + a2 * (1/w2)^sigma )^(1/(1-sigma))
xh_1
xh_2
e
```{r}
cobb_douglas_two_good_umax(
A = 1,
a1 = 0.75,
a2 = 0.25,
w1 = 6,
w2 = 5,
M = 50
)
```{r}
cobb_douglas_two_good_umax(
A = 1,
a1 = 0.75,
a2 = 0.25,
w1 = 6,
w2 = 5,
M = 50
)
---
title: "Utility Maximization and Expenditure Minimization"
```{r}
source("Utility Maximization.R")
source("Expenditure Minimization.R")
source("Utility Maximization.R")
source("Expenditure Minimization.R")
You just have to edit the parameters in the functions and "ctrl + enter" inside the cell block.
```{r}
cobb_douglas_two_good_umax(
A = 1,
a1 = 0.75,
a2 = 0.25,
w1 = 6,
w2 = 5,
M = 50
)
cobb_douglas_three_good_umax(
A = 1,
a1=0.75,
a2=0.1,
a3=0.15,
w1=8,
w2=6,
w3=7,
M=70,
)
cobb_douglas_two_good_umax(
A = 1,
a1 = 0.75,
a2 = 0.25,
w1 = 6,
w2 = 5,
M = 50
)
```{r}
cobb_douglas_three_good_umax(
A = 1,
a1=0.75,
a2=0.1,
a3=0.15,
w1=8,
w2=6,
w3=7,
M=70,
)
cobb_douglas_two_good_umax(
A = 1,
a1 = 0.75,
a2 = 0.25,
w1 = 6,
w2 = 5,
M = 50
)
```{r}
source("Utility Maximization.R")
```{r}
source("Utility Maximization.R")
source("Expenditure Minimization.R")
cobb_douglas_two_good_umax(
A = 1,
a1 = 0.75,
a2 = 0.25,
w1 = 6,
w2 = 5,
M = 50
)
# Policy changes
policy_changes = list(
c(1.04, 1.17, 1.06),
c(1.05, 0.8, 0.92),
c(0.8, 0.9, 0.95),
c(1.1, 0.88, 0.94)
)
# Old variables
a1 = 0.2
a2 = 0.8
w1 = 1
w2 = 1
M = 48
# Calculating the old V
v_old = cobb_douglas_two_good_umax(
1,
a1,
a2,
w1,
w2,
M
)
cv = c()
for (policy in policy_changes) {
# Calculating new expenditure function with new prices and old v
e_new = cobb_douglas_two_good_emin(
1,
a1,
a2,
w1 * policy[1],
w2 * policy[2],
v_old$v)
# Calculating the compensating variation with new prices and income
cv = c(cv, e_new$e - M*policy[3])
}
cv
x = c(5, 8)
w = c(2, 5)
a = x*w / sum(x*w)
a
>>>>>>> Stashed changes
